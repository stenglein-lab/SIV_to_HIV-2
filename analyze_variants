#!/usr/bin/perl

use strict;
use Data::Dumper;

my $usage = <<USAGE;

 This script outputs a table containing information about a series of variants relative to some reference sequence

 this script takes as input:

  a GFF file -> containing annotation for a reference sequence
  a VCF file -> containing variants relative to the reference sequence

 It then outputs a table, with a row for each variant described in the VCF file and 
 the following tab-delimited fields

 CDS -> name of CDS region (if variant is in a coding sequence)
 the reference AA
 the codon number (in the CDS)
 the variant AA
 whether it's a synonymous or non-syn mutation
 the variant's position in the reference sequence
 the variant's position in the CDS
 the reference sequence codon
 the variant codon
 the reference base
 the variant base
 the variant's fraction, as defined by the DP4 field in the VCF file 


 It only outputs variants with a minimum depth and minimum # of reads supporting variants as defined by the 
 parameters:

    min_overall_depth 
    min_variant_depth 

 Mark Stenglein, 3/27/2017


  usage: $0 gff_file vcf_files

USAGE


my $gff_file = shift or die "$usage\n";
my $vcf_file = shift or die "$usage\n";

open (my $gff_fh, "<", $gff_file) or die ($!);
open (my $vcf_fh, "<", $vcf_file) or die ($!);

my %cds = ();
# my %cd_to_genome_map = ();
my %genome_to_cd_map = ();
my %cds_seqs = ();
my %basemap = ();
my %seqs = ();

# parse gff file -> store annotations
parse_gff($gff_fh);

# assume std genetic code (table below)
my %genetic_code;
initialize_genetic_code();

my %histo = ();
my %lengths = ();
my %variants = ();

# print header line
print "CDS\tref_aa\tcodon_number\tvariant_aa\tSynonymous or non\tposition in genome\tposition in CDS\tref_codon\tvariant_codon\tref base\tvariant base\tvariant_fraction\n";

while (<$vcf_fh>)
{
   chomp;

   if (/^#/) 
   { 
      if (/##contig=<ID=(\S+),length=(\d+)>/)
      {
         $lengths{$1} = $2;
      }
      next;  # ignore most header lines
   } 

   my @data = split;

   my $contig = $data[0];

   # CHROM   POS   ID REF   ALT 
   my $position = $data[1];
   my $ref = $data[3];
   my @all_alt = split ",", $data[4];
   my $alt = shift @all_alt;

   if ($alt eq '<X>')
   {
      next;
   }

   my $min_overall_depth = 20;
   my $min_variant_depth = 4;
   my $ref_depth = undef;
   my $variant_depth = undef;
   my $overall_depth = undef;

   my @matched_depths = ();
   if (@matched_depths = /DP=(\d+).*DP4=(\d+),(\d+),(\d+),(\d+)/)
   {
      if (scalar @matched_depths != 5)
      {
         warn "error: unexpected format in VCF for line $_\n"; exit;
      }

      my ($depth, $d1, $d2, $d3, $d4) = @matched_depths;
      $overall_depth = $depth;


      if ($overall_depth < $min_overall_depth)
      {
         ## warn "insufficient depth: $_\n";
         next;
      }
      $ref_depth = $d1 + $d2;
      $variant_depth = $d3 + $d4;
      if ($variant_depth < $min_variant_depth)
      {
         ## warn "insufficient variant depth: $_\n";
         next;
      }
      ## print "$_\n";
   }
   else
   {
      warn "ignoring line with unexpected format in VCF: $_\n";
   }

   my $N_or_S = undef;

   $N_or_S = process_variant ($contig, $position, $ref, $alt, $ref_depth, $variant_depth, $overall_depth);

}
close $vcf_fh;

sub process_variant
{
   my $min_allele_freq = 0.05;
   my ($seg_id, $position, $ref, $alt, $ref_depth, $variant_depth, $depth) = @_;
   my $variant_fraction = sprintf ("%0.2f", $variant_depth / ($ref_depth + $variant_depth));
   if (defined $basemap{$position})
   {
      # this is in an annotated feature
      my @cds_hit = @{$basemap{$position}};
      my $cds_hit_string = join "+", @cds_hit;
      if ($variant_fraction <= $min_allele_freq)  
      {
         ## warn "$position\t$cds_hit_string\t$depth\t$ref_depth\t$variant_depth\n";
         # don't output if less than a certain frequency...
      }
      else
      {
         # warn "$position\t$cds_hit_string\t$depth\t$ref_depth\t$variant_depth\n";
         if (scalar @cds_hit > 1)
         {
            warn "** more than one CDS hit! **\n";
         }
         foreach my $cds_hit (@cds_hit)
         {
            my $position_in_cds = $genome_to_cd_map{$cds_hit}{$position};
            my $cds_seq = $cds_seqs{$cds_hit};
            my $ref_base = substr($cds_seq, ($position_in_cds-1), 1);
            if ($ref_base ne $ref)
            {
               die "error in reference base.  got: $ref_base.  expecting: $ref CDS: $cds_hit pos: $position: pos_in_cds: $position_in_cds\n";
            }
            my $alt_cds = $cds_seq;
            # change coding sequence with variant base
            substr($alt_cds, ($position_in_cds - 1), 1) = $alt;
            my $codon_number = int(($position_in_cds-1)/3) + 1;
            my $ref_codon = substr ($cds_seq, (($codon_number - 1) * 3), 3);
            my $alt_codon = substr ($alt_cds, (($codon_number - 1) * 3), 3);

            my $ref_aa = translate($ref_codon);
            my $alt_aa = translate($alt_codon);
            my $N_or_S = "S";
            if ($ref_aa ne $alt_aa)
            {
               $N_or_S = "N";
            }
            # warn "$position\t$cds_hit\t$depth\t$ref_depth\t$variant_depth\n";
            print "$cds_hit\t$ref_aa\t$codon_number\t$alt_aa\t$N_or_S\t$position\t$position_in_cds\t$ref_codon\t$alt_codon\t$ref\t$alt\t$variant_fraction\n";
         }
      }
   }
   else
   {
      # Not in an annotated position
		my $cds_hit = "NA";
		my $position_in_cds = "NA";
		my $ref = "NA";
		my $alt = "NA";
      my $codon_number = "NA";
      my $ref_codon = "NA";
      my $alt_codon = "NA";

      my $ref_aa = "NA";
      my $alt_aa = "NA";
      my $N_or_S = "NA";
      print "$cds_hit\t$ref_aa\t$codon_number\t$alt_aa\t$N_or_S\t$position\t$position_in_cds\t$ref_codon\t$alt_codon\t$ref\t$alt\t$variant_fraction\n";
   }
}

sub reverse_complement
{
   my $seq = shift @_;
   $seq = reverse ($seq); 
   $seq =~ tr/ACGTacgt/TGCAtgca/;
   return $seq;
}

sub translate
{
   my $orf = uc $_[0];
   $orf =~ tr/T/U/;
   my $orf_length = length($orf);
   my $seq = "";
   if (($orf_length % 3) != 0)
   {
      die ("the length of orf $orf is not a multiple of 3 ($orf_length)\n");
   }
   for (my $i = 0; $i < $orf_length; $i+=3)
   {
      my $codon = uc(substr ($orf, $i, 3));
      my $residue = $genetic_code{"$codon"};
      if (!defined $residue)
      {
         # probably an ambiguous base
         $residue = "?";
      }
      elsif ($residue eq "*") 
      {
         if ($i != ($orf_length-3))
         {
            warn ("error: premature stop codon at position $i\norf: $orf\n")
         }
         # don't actually output an asterisk for stop codon
         $residue = "*";
      }
      $seq .= $residue;
   }
   return $seq;
}


sub initialize_genetic_code
{
   %genetic_code = (
   'UCA' => 'S', # Serine
   'UCC' => 'S', # Serine
   'UCG' => 'S', # Serine
   'UCU' => 'S', # Serine
   'UUC' => 'F', # Phenylalanine
   'UUU' => 'F', # Phenylalanine
   'UUA' => 'L', # Leucine
   'UUG' => 'L', # Leucine
   'UAC' => 'Y', # Tyrosine
   'UAU' => 'Y', # Tyrosine
   'UAA' => '*', # Stop
   'UAG' => '*', # Stop
   'UGC' => 'C', # Cysteine
   'UGU' => 'C', # Cysteine
   'UGA' => '*', # Stop
   'UGG' => 'W', # Tryptophan
   'CUA' => 'L', # Leucine
   'CUC' => 'L', # Leucine
   'CUG' => 'L', # Leucine
   'CUU' => 'L', # Leucine
   'CCA' => 'P', # Proline
   'CAU' => 'H', # Histidine
   'CAA' => 'Q', # Glutamine
   'CAG' => 'Q', # Glutamine
   'CGA' => 'R', # Arginine
   'CGC' => 'R', # Arginine
   'CGG' => 'R', # Arginine
   'CGU' => 'R', # Arginine
   'AUA' => 'I', # Isoleucine
   'AUC' => 'I', # Isoleucine
   'AUU' => 'I', # Isoleucine
   'AUG' => 'M', # Methionine
   'ACA' => 'T', # Threonine
   'ACC' => 'T', # Threonine
   'ACG' => 'T', # Threonine
   'ACU' => 'T', # Threonine
   'AAC' => 'N', # Asparagine
   'AAU' => 'N', # Asparagine
   'AAA' => 'K', # Lysine
   'AAG' => 'K', # Lysine
   'AGC' => 'S', # Serine
   'AGU' => 'S', # Serine
   'AGA' => 'R', # Arginine
   'AGG' => 'R', # Arginine
   'CCC' => 'P', # Proline
   'CCG' => 'P', # Proline
   'CCU' => 'P', # Proline
   'CAC' => 'H', # Histidine
   'GUA' => 'V', # Valine
   'GUC' => 'V', # Valine
   'GUG' => 'V', # Valine
   'GUU' => 'V', # Valine
   'GCA' => 'A', # Alanine
   'GCC' => 'A', # Alanine
   'GCG' => 'A', # Alanine
   'GCU' => 'A', # Alanine
   'GAC' => 'D', # Aspartic Acid
   'GAU' => 'D', # Aspartic Acid
   'GAA' => 'E', # Glutamic Acid
   'GAG' => 'E', # Glutamic Acid
   'GGA' => 'G', # Glycine
   'GGC' => 'G', # Glycine
   'GGG' => 'G', # Glycine
   'GGU' => 'G'  # Glycine
   );
}


sub parse_gff
{
   my $gff_fh = shift @_;
   my $fetching_seq = 0;
   my $seq = undef;
   my $seq_id = undef;
   
   while (<$gff_fh>)
   {
     chomp;
     if (/^##/)
     {
        if (/##DNA (.*)$/)
        {
           $fetching_seq = 1;
           $seq_id = $1;
           next;
        }
        elsif (/##end-DNA/)
        {
           $seqs{$seq_id} = $seq;
           ## $seq = undef;
           $fetching_seq = 0;
        }
        if ($fetching_seq)
        {
           if (/^##(.*)$/)
           {
              $seq .= $1;
           }
        }
      }
      else
      {
      
         my @fields = split "\t";
         # Fields are: <seqname> <source> <feature> <start> <end> <score> <strand> <frame> [attributes] [comments]
         $seq_id = $fields[0];
         if (!$seqs{$seq_id})
         {
            die "error: feature refers to unknown sequence: $_\n";
         }
         if ($fields[2] eq "CDS")
         {
            my $name = $fields[8];
            if ($name =~ /Name=(\w+)/)
            {
               $name = $1;
            }
            else
            {
               die "couldn't parse name for CDS: $_\n";
            }
            my $start = $fields[3];
            my $stop = $fields[4];

            # warn "$name $start->$stop\n";

            push @{$cds{$name}{start}}, $start;
            push @{$cds{$name}{stop}}, $stop;

            for (my $i = $start; $i <= $stop; $i++)
            {
               # warn "$i\t$name\n";
               push @{$basemap{$i}}, $name;
            }

            # todo: deal w/ - strand
            my $strand = $fields[6];
            if ($strand eq '-')
            {
               die "error: don't yet support neg strand CDS \n";
            }
         }
      }
   }

   my @cds_names = keys %cds;

   foreach my $cds_name (@cds_names)
   {
      # warn "CDS: $cds_name\n";
      # get first start posn
      my @starts = sort @{$cds{$cds_name}{start}};   # TODO: co-sorting assumption OK?
      my @stops = sort @{$cds{$cds_name}{stop}};
      my @starts = @{$cds{$cds_name}{start}};  
      my @stops = @{$cds{$cds_name}{stop}};
      my $cds_position = 1;
      foreach my $start (@starts)
      {
         ## warn "** break **\n";
         my $stop = shift @stops;
         for (my $genome_position = $start; $genome_position <= $stop; $genome_position++)
         {
            # $cd_to_genome_map{$cds_name}{$cds_position} = $genome_position;
            $genome_to_cd_map{$cds_name}{$genome_position} = $cds_position;
            # warn "$genome_position\t$cds_name:$cds_position\n";

            # $cds_seqs{$cds_name}{$cds_position} = substr ($seq, ($cds_position-1), 1);
            $cds_seqs{$cds_name} .= substr ($seq, ($genome_position-1), 1);
            $cds_position += 1;
         }
      }
   }
}

